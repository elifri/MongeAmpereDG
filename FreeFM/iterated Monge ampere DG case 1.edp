 mesh Th=square(1,1);
 Th = trunc(Th,1, split=2);
 fespace Vh(Th,P2dc);     // P1 FE space
 Vh uh, wh,phih;              // unkown and test function. 

 macro norm()
	sqrt(x*x+y*y) //
 
func real rhsFunc(real x, real y)
{
	real r = 2*(1-(0.2/norm));
	if (r > 0) return r;
    return 0;
}

//func f = 8;
func f = (1 + square(x)+square(y)) *  2*exp(square(x)+square(y));//  right hand side function 
// func f = rhsFunc(x,y);

func g = exp( (square(x)+square(y))/2. ); //  boundary condition function /exact solution
//func g = square((norm - 0.2) * (norm > 0))/2.;
//func g = 2*x*x + 2*y*y + 3*x*y;

 wh = g; 
 //wh = x*x/2.+y*y/2.;
cout <<"g " <<  g(1,1) << endl;
cout << "wh " << wh(1,1) << endl;

//real a11 = 4, a12 = -3, a21 = -3, a22 = 4;
//func diffmatrix = [[a11, a12], [a21, a22]];

real sigma = 7*20;

int maxIt = 20;

macro Grad(u)
[dx(u),dy(u)] //

macro GradTimesA(u, v, A) 
    Grad(u)'*A*Grad(v) //

macro calcCofHess(z)
	[[dyy(z),-dxy(z)],[-dyx(z),dxx(z)]] //

for (int iteration = 0; iteration < maxIt; iteration++)
{

	sigma *= (iteration+1)*10;
	varf Abilin(uh,phih,tgv=1e5) =                    //  definion of  the problem 
    	int2d(Th)( -1* GradTimesA(phih, uh, calcCofHess(wh)) ) //  bilinear form
		+intalledges(Th)( jump(phih) * mean([N.x,N.y]'*calcCofHess(wh)*Grad(uh)) 
						  +jump(uh) * mean(-1* [N.x,N.y]'*calcCofHess(wh)*Grad(phih)) 
        	             )
	    +intalledges(Th)(sigma/lenEdge * jump(uh)*jump(phih) ) //penalty therm
 	;	

	varf rhsbilin(uh,phih) =  int2d(Th)( f*phih )           //  linear form
   		+int1d(Th,1,2,3,4)( (nTonEdge)* (g* ([N.x,N.y]'*calcCofHess(wh)*Grad(phih)) 
							            +sigma/lenEdge *g*phih
 	 	                                )  //for all boundary term weak bound. cond.
    		                )
	//  + on(1,2,3,4,uh=g)  //  boundary condition form
	;         

	matrix A = Abilin(Vh,Vh);

	real[int] rhs = rhsbilin(0,Vh);
	set(A,solver=sparsesolver);
	uh[] = A^-1*rhs;
  
	string s ="data/Monge Ampere"+iteration+".eps"; 
	plot(uh,ps=s,value=true);

//==========================================
//===============produce output=============
//==========================================

  int n= 400;
   real N = n;
	s = "data/case1_MongeAmpereDG"+iteration;
	ofstream gnu(s), points("data/points");
    gnu << "n_x " << (n+1) << " n_y " << (n+1) << endl
        << " h_x " << 1/N << " h_y " << 1/N << endl
        << " x_0 " << 0 << " y_0 " << 0 << endl;

  real[int] xx(n*n+1), xy(n*n+1), yy(n*n+1);
  for (int i = 0; i<= n; i++)
   {
    for (int j = 0; j <= n; j++)
   {
   x  = j/N; y = i/N;
   xy[i] = y;
   xx[i] = x;
   yy[i] = uh;

   points << x << " " << y << " " << yy[i] << endl;
   gnu << yy[i] << endl;
   }
  }
  
//==========write out cofactor matrices========
	s = "data/info"+iteration;
	ofstream cof(s);

	cof << "A\n "<< A << endl; 

	cof << "cofactor matrices" << endl;
    cof << "n_x " << (n+1) << " n_y " << (n+1) << endl
        << " h_x " << 1/N << " h_y " << 1/N << endl
        << " x_0 " << 0 << " y_0 " << 0 << endl << endl;

  for (int i = 0; i<= n; i++)
   {
    for (int j = 0; j <= n; j++)
   {
   x  = j/N; y = i/N;

	cof << "at " << x << " " << y << " " << endl;
   cof << dyy(uh) << " " << -dxy(uh)<< endl;
   cof << -dyx(uh) << " " << dxy(uh)<< endl << endl;
   }
  }
  
  real[int] array= uh[];

//======write out Lsolution coefficients=========
	s = "data/solution coefficients"+iteration;
	ofstream sol(s);
	sol << "Lsolution :\n"; 
	for (int i =0; i <uh.n; i++)
     {
       sol << array[i] << " " << endl;
     }

//=========write to vtk file===============
	s = "data/FreeFEMsolution"+iteration+".vtu";
  	ofstream file (s);

//header
	file << "<?xml version=\"1.0\"?>\n"
			<< "<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n"
			<< "\t<UnstructuredGrid>\n\n";

	file << "\t\t<Piece NumberOfPoints=\"" << Th.nv << "\" NumberOfCells=\""
			<< Th.nt << "\">\n";

// write points
	file << "\t\t\t<Points>\n"
			<< "\t\t\t\t<DataArray type=\"Float32\" NumberOfComponents=\"3\" format=\""
			<< "ascii" << "\">\n";
	for (int i=0;i<Th.nv;i++) 	
		file << "\t\t\t\t\t" << Th(i).x << " " << Th(i).y << " " << wh(Th(i).x,Th(i).y) << endl;

	file << "\t\t\t\t</DataArray>\n" << "\t\t\t</Points>\n";

// write cells

	file << "\t\t\t<Cells>\n"
			<< "\t\t\t\t<DataArray type=\"Int32\" Name=\"connectivity\" format=\"";
	file << "ascii\">"<<endl;
	// make connectivity
	for (int i=0;i<Th.nt;i++) // loop over triangles
			file << "\t\t\t\t\t"<< Th[i][0] << " " << Th[i][1] << " " << Th[i][2] << " ";
	file << "\n\t\t\t\t</DataArray>\n";

	file
			<< "\t\t\t\t<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">\n\t\t\t\t\t";
	for (int i = 1; i <= Th.nt; ++i)
		file << 3*i << " ";
	file << "\n\t\t\t\t</DataArray>";
	file
			<< "\n\t\t\t\t<DataArray type=\"Int32\" Name=\"types\" format=\"ascii\">\n\t\t\t\t\t";
	for (int i = 1; i <= Th.nt; ++i)
		file << "5 ";  // 5: triangle, 9: quad
	file << "\n\t\t\t\t</DataArray>";
	file << "\n\t\t\t</Cells>\n";

	file << "\n\t\t</Piece>";
	file << "\n\t</UnstructuredGrid>\n" << "\n</VTKFile>";


	wh = uh;
}