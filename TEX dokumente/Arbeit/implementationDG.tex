\section{Implementation of a SIPG Method}

In this section we mention the main problems arising at an implementation of the presented SIPG method (cf. Section \ref{sec: SIPG}). A detailed survey of issues of an implementation of (conforming) finite element methods can be found in \cite[Section 0.6]{BS2002} and \cite[Chapter 8]{Braess2003}. 

We assume that $\Omega$ is polygonal and that we have given a regular triangulation of $\Omega$. One main problem in the implementation of a SIPG method (or any finite element method) is the assembly of the stiffness matrix defined by the left-hand side inner product. As suggested in the form in \eqref{eq:inner product SIPG} we individually evaluate the integrals on every triangle or edge, respectively. %Note that this is one difference to conforming finite element methods: As those elements do have support in more than one triangle one iterates 

\subsection{Integration scheme}
First, to evaluate an integral numerically we need a quadrature rule. Usually Gauss quadrature is the method of choice as it provides a good order of exactness using only a few points. To approximate the integral $\myIntX {\phantom{x}} {h(x)} $ a Gauss quadrature formula $\sum_{i=1}^{N} w_i h(q_i)$ needs to evaluate $h$ at certain quadrature points $q_i$. For the case $N=7$ we show the quadrature points for a triangular domain in Figure \ref{fig: quadrature} approximations calculated with these point are exact up to a polynomial degree of 5 \cite[p.314]{Strout1971}.
\begin{figure}[!h]
	\centering
	\input{quadrature.pgf}
	\caption{Quadrature points for a integral over a triangle domain with $N=7$}
	 \label{fig: quadrature}
\end{figure}
Quadrature formulas, i.e. quadrature points and weights, especially for handling volume integrals can be found in \cite{Strout1971}.
To assemble the stiffness matrix $M$ the data we have to provide reduces to the functions values at the element or face quadrature points, respectively.  
In the SIPG method we have to evaluate the bilinear form and the functional in \eqref{eq: DG system} for every combination of test functions. This means, at an element quadrature point we require the gradients, whereas at a face quadrature point we need information about the function values $u$ and the normal derivatives, i.e. $\nabla u \cdot \mathbf{n}$ of all test functions.

\subsection{A Reference Cell} \label{subsec: ref cell}
To reduce the storage space one usually specifies a \emph{reference cell} $T_{ref}$: We aim to relate triangles attributes to the reference cell attributes. There is for each triangle $T \in \triang$ an affine transformation $\Phi_T:T_{ref} \rightarrow T$ such that $\Phi_T$ maps $T_ref$ into $T$ and $\Phi$ maps the nodes of $T_ref$ onto the nodes of $T$.
%We make use of the triangle spanned by the points $(0,0)^t, (0,1)^t$ and $(1,0)^t$ for our reference cell. 
Since the DG spaces also allow discontinuous functions, a basis $p^1_{ref},\dots,p^n_{ref}$ of $T_{ref}$ also induces a basis on every $T$ via $\Phi_T$, namely the basis consisting of 
\[
	p_T^i(x) := p^i_{ref}(\Phi_T^{-1}(x)), \qquad x \in T, 1 \leq i \leq n.
\]
The most famous basis polynomials are the Lagrange elements: Given a set of points $P$ each Lagrange basis element evaluates at exactly one point of $P$ to one and vanishes at every other point of $P$. Due to this property this basis is also referred as a nodal basis. 
A huge benefit of the Lagrange elements are they form a interpolatory basis, i.e. the coefficients of a polynomial in Lagrange representation are the function values at the points of $P$.

Now most of the required data on a triangle $T$ can be easily derived knowing $\Phi_T$ and the reference cell $T_{ref}$. We explain how to do that in detail for the two-dimensional case.

\begin{example}\label{ex: base cell trafo}
During this example we consider $\Omega \subset \R^2$ and we choose the reference triangle to be the standard simplex, which is the triangle spanned by the points $\point 0 0, \point 1 0$ and $\point 0 1$.
Suppose we want to figure out the transformation for the triangle $T = \langle v_0,v_1,v_2 \rangle$.
It has to hold
\[
\Phi_T\left(\point 0 0\right) = v_0, \Phi_T\left(\point 1 0 \right) = v_1 \textnormal{ and } \Phi_T\left(\point 0 1\right) = v_2.
\]
Since every two-dimensional affine transformation can be written in the form $\Phi(x) = Ax+b$ for some $A \in \R^{2 \times 2}$ and $b \in \R^2$ it is easy to verify that we have $A = \begin{pmatrix} v_1-v_0 & v_2-v_0\end{pmatrix}$ and $b = v_0$.
Having determined the transformation we are able to calculate its inverse $\Phi_T^{-1}(x) = A^{-1} (x-b) =: A^{-1} x- \tilde b$.
Combining the reference cell concept with barycentric coordinates we gain a connection between original and reference triangle. Let $\beta_0, \beta_1$ and $\beta_2$ be the barycentric coordinates of $x \in T$. We find
\begin{align*}
	p^i_T(x) =& p_T^i( \beta_0 v_0 +\beta_1 v_1 + \beta_2 v_2  ) \\
	=& p^i_{ref}(\Phi_T^{-1}(\beta_0 v_0 +\beta_1 v_1 + \beta_2 v_2)) \\
	=& p^i_{ref}(A^{-1}(\beta_0 v_0 +\beta_1 v_1 + \beta_2 v_2)- \tilde b)
\end{align*}
We recall that for barycentric coordinates $\sum_{i=0}^2 \beta_i = 1$ is valid and thus,
\begin{align*}
	p^i_T(x)
	=& p^i_{ref}(\beta_0(A^{-1}v_0 -\tilde b) +\beta_1(A^{-1}v_1 -\tilde b) + \beta_2(A^{-1}v_2 -\tilde b))\\
	=& p^i_{ref}(\beta_0 \Phi_T^{-1}(v_0) +\beta_1 \Phi_T^{-1}(v_1) + \beta_2 \Phi_T^{-1}(v_2)) \\
	=& p^i_{ref}(\beta_0 \point 0 0 +\beta_1 \point 0 1 + \beta_2 \point 1 0 ), \qquad 1 \leq i \leq n.
\end{align*}
Thus, basis function values in $T$ can be simply determined using barycentric coordinates. Henceforth we refer with $x_{ref}$  to the point $\beta_0 \point 0 0 +\beta_1 \point 0 1 + \beta_2 \point 1 0$ which is the to $x$ corresponding point in the reference triangle. In Figure \ref{fig: transformation} the connection between $x_{ref}$ and $x$ is shown.

\begin{figure}[H]
	\input{transformation.pgf}
	\caption{Transformation of reference cell}
	 \label{fig: transformation}
\end{figure}

Similarly we can affiliate the determination of the gradient in $T$ to a calculation in $T_{ref}$. With the chain rule we have
\begin{align*}
	\left(\nabla_x p_T^i(x)\right)^t = D_x p_T^i(x) =& D_x p^i_{ref}(\Phi_T^{-1}(x)) \\
	  =& D_{\Phi_T^{-1}(x)}p^i_{ref}(\Phi_T^{-1}(x)) \cdot D_x  \Phi_T^{-1}(x) \\
	  =& D_{x_{ref}}p^i_{ref}(x_{ref}) \cdot  A^{-1}
\end{align*}
and thus
\begin{align}
	\nabla_x p_T^i(x) = A^{-t} \cdot \nabla_{x_{ref}}p^i_{ref}(x_{ref}), \qquad 1 \leq i \leq n. \label{eq: ref gradient}
\end{align}

Analogous proceeding yields for the Hessian matrix
\begin{align}
D_x^2p_T^i(x) = A^{-t} D_{x_{ref}}^2p^i_{ref}(x_{ref})  A^{-1}, \qquad 1 \leq i \leq n.
\end{align}

Concluding, if we need to determine function values, gradient and Hessian of a basis function on a cell, we only need the Jacobian of its transformation, i.e. $A$. We are able to calculate all further information with the data provided by the reference triangle.
\end{example}

\subsection{Refinement and Base Cells}\label{subsec: refinement and base cells}
In the rest of this section let us assume we have a fixed triangulation of a two-dimensional domain $\Omega$. 
Suppose the mesh of our triangulation is created by a refinement of a coarser mesh. We choose a specific kind of uniform refinement: Given a triangulation $\triang$ every triangle $T \in \triang$ is divided into four congruent triangles as is shown in Figure \ref{pic: refinement}. We note that the diameter of each triangles in the finer grid is halved and therefore we denote the finer grid by $\triangFine$. %Additionally the small triangles inherit the same angles as the original cell as we verify with the intercept theorem.

\begin{figure}[h]
\input{refinement.pgf}
\caption{Refinement of a triangle}
 \label{pic: refinement}
\end{figure}

We associate the new refined triangles with the original cell which we call their \emph{base cells} $B$. Repeating the refinement we can always relate a cell in the finest mesh with a base cell in the original triangulation. We can find an affine mapping $\Psi_T:B \rightarrow T$ transforming the base cell $B$ to $T$ such that $\Phi_T = \Psi_T \circ \Phi_B$. This implies also that for the Jacobians $A_{\Phi_T}, A_{\Psi_T}, A_{\Phi_B}$ of the affine transformations $\Phi_T, \Psi_T,\Phi_B$ holds
\begin{align}
A_{\Phi_T}=A_{\Psi_T} A_{\Phi_B}
\end{align} 

This makes saving information about the base cell very beneficial as the transformation matrix $A_{\Psi_T}$ is a diagonal matrix which is even a multiple of the identity matrix. It follows that basis function data on two triangles with the same base cell only differs in a constant factor. Yet another benefit of the relation between cells and their base cells is they have the same, or for the innermost triangle ($T_0$ in figure \ref{pic: refinement}) opposite directed, normals.

\begin{example}\label{ex: leaf cell trafo}
In the two-dimensional case the Jacobian $A_{\Psi_T}$ of a transformation $\Psi_T$ from the base cell $B$ to one of its $l$ times refined triangle $T$ is $
	\begin{pmatrix}
		\frac 1 {2^l} & 0 \\ 0 & \frac 1 {2^l}
	\end{pmatrix} \text{ or }
	\begin{pmatrix}
		-\frac 1 {2^l} & 0 \\ 0 & -\frac 1 {2^l}
	\end{pmatrix}$, respectively if the number of intermediate base cells being an inner triangle during refinement  has been odd.

 For each point $x \in T$ we can determine a corresponding base cell point $x_B$, namely the point which satisfies $x = \Psi_T(x_B)$. With the help of \eqref{eq: ref gradient} we find the identity
\begin{align}
\nabla_x p_T^i(x) &= A_{\Phi_T}^{-t} \nabla_{x_{ref}} p^i_{ref} (x_{ref}) \nonumber\\
 &= A_{\Psi_T}^{-t} A_{\Phi_B}^{-t} \nabla_{x_{ref}} p^i_{ref} (x_{ref}) \nonumber\\
&= \epsilon 2^l A_{\Phi_B}^{-t} \nabla_{x_{ref}} p^i_{ref}(x_{ref}), \qquad \epsilon \in \{+,-\} \label{eq: trafo grad},
\end{align}
with $l \in \N$ indicating how often $T$ is refined with respect to the original mesh.\\
Analogously we have
\begin{align}
\nabla_x p^i(x) \mathbf n &= 2^l  A_{\Phi_B}^{-t} \cdot \nabla_{ref}p^i_{ref}(x_{ref}) \mathbf{ n_{b}} \qquad \text{ and } \label{eq: trafo normal der} \\
D_x^2 p^i(x) &= 2^{2l}  A_{\Phi_B}^{-t} D_{x_{ref}}^2 p^i_{ref}(x_{ref}), \qquad 1 \leq i \leq n,
\end{align}
where $\mathbf n_b$ is the to $n$ corresponding normal in the base cell. Note that \eqref{eq: trafo normal der} even holds for inner refined triangles: The minus sign of the gradient cancels with the minus sign of the base cell normal $n_B$ since $n_B$ is opposite directed as the corresponding normal $n$ of a inner triangle.\\
Another case where the sign of the gradient \eqref{eq: trafo grad} could be important occurs when we evaluate the first part of the bilinear form, i.e. $\nabla \phi \cdot A \nabla v$. We first note that two basis functions $p_T^i$ and $p_T^j$ having only support on $T$ are created with the same affine mapping $\Phi_T$. Hence they have the same transposed, inversed Jacobian $A^{-t}_{\Phi_T}=\epsilon 2^l A_{\Phi_b}^{-t}$ and therefore the sign on the right-hand side in \eqref{eq: trafo grad} is for both gradients the same. Because we multiply both gradients a sign change between base and the actual cell does not affect the evaluation of our bilinear form. 
Of course for other combinations of basis polynomials the latter volume integral always equals zero because the polynomials' support is chosen in such a way that all other gradients vanish in the interior of $T$.

A common source of errors are the signs of the terms
\begin{align}
	\jump {v \average{ A \nabla w }} = v^+ \frac 1 2  \left(A^+ \nabla w^+ + A^- \nabla w^-\right) \cdot \mathbf n^+ + v^- \frac 1 2 \left(A^+ \nabla w^+ + A^- \nabla w^-\right) \cdot \mathbf n^-. \label{eq: error source edge terms}
\end{align}
Since for two adjacent triangles always $\mathbf n^+ = - \mathbf n^-$ holds, we also have $A^+ \nabla w^+ \mathbf n^-= -A^+ \nabla w^+ \mathbf n^+$ and $A^- \nabla w^- \mathbf n^+= -A^- \nabla w^- \mathbf n^-$. Hence we can calculate all terms in \eqref{eq: error source edge terms} using \eqref{eq: trafo normal der}. Note that all basic functions have support on only one triangle, such that we have for an evaluation of a basic function $v_B$ either $v_B^+$ or $v_B^-$, as well as for a basic function $w_B$ either $w_B^+$ or $w_B^-$, is equal to zero.

So, we are able to save a lot of memory if we store instead of all data at every quadrature points in each refined cell just the data of the base cell and the number of refinements. The refined cells contained in the actual mesh are referred to as \emph{leaf cells}.
\end{example}

\subsection{Assembly Loop}\label{subsec: assembly loop}
Another crux of the implementation is the handling of edge terms, let us be more specific: We mentioned earlier that we evaluate the bilinear form cell-wise. Hence the volume integrals are calculated visiting every cell only once. Let us now consider when do we compute the edge integrals.\\

Face terms can be assembled in two simple or a single more complex step.
For the two-step variant the face terms are split up into the contributions of their two adjacent cells, such that the first part is assembled when processing the first to the edge adjacent cell and the second during the processing of the other adjacent cell. \\
In the one step variant we handle a face term when visiting an adjacent cell for the first time. To detect the first time we introduce a flag for every leaf cell indicating whether the cell has been processed yet. Now, each time the assembling algorithm visits a face it determines the neighbouring cell and checks if the face has already been processed. 

Algorithm \ref{alg: assembling} from \cite{BMV2009} illustrates how to perform this one step approach. 
The advantage of this approach that it can be easily extended to the case of a non-uniform refinement, i.e. adjacent base cells are not necessarily refined equally often, and different kinds of cell types.

\begin{algorithm}[h]
\caption{An assembling loop for a DG method}
\label{alg: assembling}
\begin{algorithmic}
\Ensure every cell flag is false
\For {cell in all leaf cells}  
\State get cell data
\State assemble volume integrals 
	\For {face in faces(cell)}
		\If {neighbour across the face exists} 
			\If {neighbour flag not set}
					\State get neighbour cell data
					\State assemble face terms
			\EndIf
		\Else
			\State assemble boundary terms
		\EndIf
\EndFor
	\State cell flag to true 
\EndFor
\State Reset every cell flag to false
\end{algorithmic}
\end{algorithm}

In \cite{BMV2009} Brix et al. also develop a data structure efficiently handling all the mentioned requirements among a lot of other features. The implementation used for the Numerical Results in Section \ref{sec: numerical results our Method} is based on this data structure.
