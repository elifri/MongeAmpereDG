#ifndef UTILITY_HPP
#define UTILITY_HPP

#include <algorithm>
#include <cmath>
#include <iostream>
#include <string>

#include <Eigen/Core>
#include <Eigen/Sparse>
#include <Eigen/Dense>

#ifdef USE_PETSC
#include "petscksp.h"
#endif

typedef Eigen::SparseMatrix<double> SparseMatrixD;

/**
 * Macro for debugging output
 * Advantage: If DEBUG is not set, no code is generated by the compiler.
 *            If level is to low, the if statement is ignored by the
 *            optimization techniques of the compiler whenever the
 *            condition in the if statement can be evaluated at compile time.
 *
 * @param level minimum level to display output
 * @param output text to output, use like ostream
 *
 */
#ifdef DEBUG
  #define debugoutput(level,output) {if(DEBUG >= level) { cout << output; }}
  #define debugoutputcond(level,output,condition) {if(DEBUG >= level && (condition)) { cout << output; }}
#else
  #define debugoutput(level,output) {}
  #define debugoutputcond(level,output,condition) {}
#endif

const double Pi=4.0 * std::atan2(1.0, 1.0);

template < typename T >
/** Convert number to string.
 *
 * @param number number to convert
 * @return string containing number
 */
std::string NumberToString(const T number)
{
  std::stringstream str;

  str << number;
  if(str.fail())
  {
    throw("Conversion from number to string failed.");
  }
  std::string s(str.str());

  return s;
}

/** Calculate square of a double.
 *
 * @param x given double
 * @return square of x
 */
inline double sqr(const double &x){return x*x;}

/** Calculate factorial by loop.
 *
 * @param n given number
 * @return factorial of n
 */
unsigned long int factorial(const unsigned long int &n);

/** Calculate binomial coefficient "n choose k".
 *
 * @param n upper parameter
 * @param k lower parameter
 * @return binomial coefficient "n choose k"
 */
int binomial(const unsigned long int &n, const unsigned long int &k);


/** Output separator line to standard output
 */
void outputseparator();

////////////////////////////////////////////////////
///////////////                      ///////////////
///////////////   fixpoint format    ///////////////
///////////////                      ///////////////
////////////////////////////////////////////////////

// author James Kanze
// usage: cout << FFmt( 6 , 4 ) << f1 << FFmt( 8 , 5 ) << f2 << '\n' ;
// see also http://groups.google.de/group/de.comp.lang.iso-c++/browse_thread/thread/c3f95adf67bad7c1/9ef68ceb7959edbf?lnk=st&q=myOwner-%3Eflags&rnum=1&hl=de#9ef68ceb7959edbf

class FFmt
{
public:
  FFmt(int width, int precision);
  ~FFmt();
  friend std::ostream & operator<<(std::ostream &, FFmt const &);
private:
  int myWidth;
  int myPrecision;
  std::ios *myOwner;
  std::ios::fmtflags myOriginalFlags;
  int myOriginalPrecision;
  char myOriginalFill;
  int myPointerIndex;
};

std::ostream & operator<<(std::ostream & dst, FFmt const &format);

#ifdef USE_PETSC

void check_petsc_error(PetscErrorCode ierr);

#endif

template <class Cont>
Cont toupper(Cont cont);

bool string_contains_true(const std::string s);


#endif
